(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.1'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[     56048,       1608]*)
(*NotebookOutlinePosition[     56740,       1632]*)
(*  CellTagsIndexPosition[     56696,       1628]*)
(*WindowFrame->Normal*)



Notebook[{

Cell[CellGroupData[{
Cell["Random numbers and random matrices:", "Title"],

Cell["where quantum chaos meets number theory", "Subtitle"],

Cell[CellGroupData[{

Cell["Introduction", "Section"],

Cell[TextData[{
  "This is a ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " notebook to accompany the article \"Random Numbers and Random Matrices: \
quantum chaos meets number theory\", which has been submitted to the American \
Journal of Physics.  All of the calculations discussed and presented in the \
article can be carried out using this notebook.  I do not include much \
description of the physical relevance of the various calculations since that \
is covered in depth in the article (so please consult the article for that \
information).  Instead I provide here a brief description of the calculations \
and the code to implement them in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  ".  I have tried to make each section self-contained, although the plots of \
the theoretical distributions are not redone in each section.  Use ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "'s Help feature for descriptions of the individual commands.  If you have \
any questions about this material feel free to contact me at \
ttimberlake@berry.edu."
}], "Text"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Plots of the Theoretical Distrubutions", "Section"],

Cell["\<\
In this section we create plots of the various Wigner distributions \
and the Poisson distrubution, as well as the Wigner semicircle law.  These \
will be used later to compare calculated distributions to these theoretical \
predictions.  The actual limiting distributions for random matrices are \
slightly different from the Wigner distributions.\
\>", "Text"],

Cell["Here's a plot of the Poisson distribution.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Poisson = 
      Plot[Exp[\(-s\)], {s, 0, 5}, 
        PlotStyle \[Rule] {Thickness[0.015]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Below we plot the theoretical density of eigenvalues known as Wigner's \
semicircle law (because the curve takes the shape of a semicircle centered at \
zero with radius ",
  Cell[BoxData[
      \(TraditionalForm\`\(\(\@\(2  N\)\)\(,\)\)\)]],
  "where N is the dimension of the random matrix (and hence the number of \
eigenvalues)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(WSC = 
      Plot[Sqrt[2*n - x^2]/\((Pi)\), {x, \(-Sqrt[2*n]\), Sqrt[2*n]}, 
        PlotStyle \[Rule] {Thickness[0.02]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Here's the Wigner distribution for random real symmetric matrices \
(which is very close to the Gaussian Orthogonal Ensemble distribution).\
\>", \
"Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(GOE = 
      Plot[Pi*s*Exp[\(-Pi\)*s^2/4]/2, {s, 0, 5}, 
        PlotStyle \[Rule] {Thickness[0.01]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Here's the distribution for a combination of two GOE data \
sets.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(GOE2 = 
      Plot[Exp[\(-Pi\)*s^2/8]/2\  + \ 
          Pi*s*Exp[\(-Pi\)*s^2/16]*Erfc[Sqrt[Pi]*s/4]/8, {s, 0, 5}, 
        PlotStyle \[Rule] {Thickness[0.01]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Next we plot both the Poisson distribution (dashed) and the GOE or \
2 GOE distribution (solid) together.  This will help to illustrate the \
transition from random to random-matrix statistics in our quantum map.\
\>", \
"Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Curves1 = 
      Plot[{Exp[\(-s\)], Pi*s*Exp[\(-Pi\)*s^2/4]/2}, {s, 0, 5}, 
        PlotStyle \[Rule] {{Thickness[0.01], Dashing[{0.02, 0.02}]}, 
            Thickness[0.01]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Curves2 = 
      Plot[{Exp[\(-s\)], 
          Exp[\(-Pi\)*s^2/8]/2\  + \ 
            Pi*s*Exp[\(-Pi\)*s^2/16]*Erfc[Sqrt[Pi]*s/4]/8}, {s, 0, 5}, 
        PlotStyle \[Rule] {{Thickness[0.01], Dashing[{0.02, 0.02}]}, 
            Thickness[0.01]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Finally we plot the Wigner distribution for random complex \
Hermitian matrices (which is very close to the Gaussian Unitary Ensemble \
distribution).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(GUE = 
      Plot[32*s^2*Exp[\(-4\)*s^2/Pi]/Pi^2, {s, 0, 5}, 
        PlotStyle \[Rule] {Thickness[0.015]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Random Numbers", "Section"],

Cell[TextData[{
  "In this section we look at the spacing distribution for random numbers, to \
see that is follows the Poisson distribution.  The code below generates a \
list of 10,000 random numbers (all between 0 and 1), sorts them, rescales \
them so that the means spacing between consecutive numbers is 1, and then \
generates a histogram of the frequencies of different level spacings.  To \
generate the histogram you need to load the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Graphics package first."
}], "Text"],

Cell[BoxData[
    \(<< Graphics`\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(n = 10000;\)\), "\n", 
    \(\(R = Sort[Table[Random[], {i, 1, n + 1}]];\)\), "\n", 
    \(\(RSpacing = Table[R[\([i + 1]\)] - R[\([i]\)], {i, 1, n}];\)\), "\n", 
    \(\(RSpacingNorm = RSpacing/Mean[RSpacing];\)\), "\n", 
    \(\(int\  = \ Table[0 + i/8, {i, 0, 40}];\)\), "\n", 
    \(RHist = 
      Histogram[RSpacingNorm, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \(Histogram::"rtail" \(\(:\)\(\ \)\) 
      "Warning: \!\(76\) points from the right tail of the data, greater than \
or equal to \!\(5\), are not included in histogram."\)], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Next we show the level spacing histogram along with a plot of the \
Poisson distribution. It is clear from the results that random numbers have a \
Poisson level spacing distribution. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[RHist, Poisson, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Random Matrix - GOE", "Section"],

Cell["\<\
In this section we will generate a Gaussian-random real symmetric \
matrix, compute its eigenvalues, calculate the level spacings, and generate a \
histogram of these level spacings.  This histogram closely matches the GOE \
distribution.  Be aware that these calculations take some time (roughly 900 \
seconds on a PowerMac G4 733 MHz).\
\>", "Text"],

Cell[TextData[{
  "First we must construct the matrix.  To do this we need to load the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " package entitled \"Continuous Distributions\" that is contained within \
the Statistics package."
}], "Text"],

Cell[BoxData[
    \(<< Statistics`ContinuousDistributions`\)], "Input"],

Cell["\<\
Now we construct and n by n random real symmetric matrix.  Each \
matrix element is a random number and these numbers are Gaussian distributed \
with a mean of zero and a standard deviation of one (except the diagonal \
elements which have a standard deviation of square root of 2).  Here we \
generate a 3000 by 3000 matrix.  Once the matrix is generated we can find its \
eigenvalues and sort them.\
\>", "Text"],

Cell[BoxData[{
    \(\(n = 3000;\)\), "\n", 
    \(\(M = 
        Table[Which[i \[Equal] j, Random[NormalDistribution[0, 1]], i < j, 
            Random[NormalDistribution[0, 1/Sqrt[2]]], i > j, 0], {i, 1, 
            n}, {j, 1, n}];\)\), "\n", 
    \(\(MFull = 
        Table[Which[i \[GreaterEqual] j, M[\([j, i]\)], i < j, 
            M[\([i, j]\)]], {i, 1, n}, {j, 1, 
            n}];\)\), "\[IndentingNewLine]", 
    \(\(GOEev = Sort[Eigenvalues[MFull]];\)\)}], "Input"],

Cell["\<\
As mentioned in the article, the distribution of eigenvalues from a \
random matrix thins out toward the edges.  We can illustrate this by plotting \
a histogram of the density of the eigenvalues, as shown below.  The density \
is clearly much lower near the edges of the range of values.  Indeed, the \
histogram looks very much like a semicircle centered at zero.  Note that we \
need to load the Graphics package if it has no already been loaded.\
\>", \
"Text"],

Cell[BoxData[
    \(<< Graphics`\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(GOEDensity = 
      Histogram[GOEev, HistogramCategories \[Rule] 25, 
        HistogramScale \[Rule] n, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<E\>", "\<\[Rho](E)\>"}, 
        RotateLabel \[Rule] False]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Below we plot the theoretical density of eigenvalues known as Wigner's \
semicircle law (because the curve takes the shape of a semicircle centered at \
zero with radius ",
  Cell[BoxData[
      \(TraditionalForm\`\(\(\@\(2  N\)\)\(,\)\)\)]],
  "where N is the dimension of the random matrix (and hence the number of \
eigenvalues)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(WSC = 
      Plot[Sqrt[2*n - x^2]/\((Pi)\), {x, \(-Sqrt[2*n]\), Sqrt[2*n]}, 
        PlotStyle \[Rule] {Thickness[0.02]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below shows a comparison of Wigner's semicircle law to the \
computed eigenvalue density.  The agreement is excellent.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[GOEDensity, WSC, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
To analyze the level spacing statistics we must unfold the sequence \
of eigenvalues so that the unfolded eigenvalues are distributed uniformly on \
large scales (there will, of course, still be fluctuations about uniformity \
on small scales - that's what we want to focus our attention on).  For a \
sequence that follows the Wigner semicircle law the unfolded eigenvalues are \
given by\
\>", "Text"],

Cell[BoxData[
    \(e = \((E \@\( 2  N - E\^2\) + 
            2  N\ \(sin\^\(-1\)\) \((E/\@\(2  N\))\) + 
            N\ \[Pi])\)/\((2  \[Pi])\)\)], "DisplayFormula"],

Cell[TextData[{
  "The plot below shows the density of these unfolded eigenvalues.  As \
expected, the density is essentially uniform.  Note: watch out for \
eigenvalues with absolute value greater than ",
  Cell[BoxData[
      \(TraditionalForm\`\@\(2  N\)\)]],
  ", which can occasiaonally occur, because these will lead to complex \
unfolded eigenvalues which will produce an error when constructing the \
histogram."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(UGOEev = 
      Table[\((GOEev[\([i]\)]*Sqrt[2*n - GOEev[\([i]\)]^2] + 
              2*n*ArcSin[GOEev[\([i]\)]/Sqrt[2*n]] + n*Pi)\)/\((2*Pi)\), {i, 
          1, n}]; GOEDensity = 
      Histogram[UGOEev, HistogramCategories \[Rule] 25, 
        HistogramScale \[Rule] n, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<e\>", "\<\[Rho](e)\>"}, 
        RotateLabel \[Rule] False]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
 The code below calculates the spacings for the unfolded \
eigenvalues and generates a hisogram of the spacings.  \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(SpcGOEev = 
        Table[UGOEev[\([i + 1]\)] - UGOEev[\([i]\)], {i, 1, 
            n - 2}];\)\), "\n", 
    \(\(int\  = \ Table[0 + i/8, {i, 0, 40}];\)\), "\n", 
    \(GOEHist = 
      Histogram[SpcGOEev, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Below we create a plot that compares the level spacing hisogram of \
our random real symmetric matrix to the GOE distribution.  We see that that \
agreement is very good.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[GOEHist, GOE, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Random Matrix - 2 GOEs", "Section"],

Cell[TextData[{
  "In this section we generate a level spacing histogram for a combination of \
eigenvalues from two random real symmetric matrices.  The code below \
generates the two random matrices, finds their eigenvalues, unfolds the \
eigenvalues so that they are distributed uniformly on a large scale, combines \
the unfolded eigenvalues into a single list, and sorts them.  Note: this will \
take roughly twice as long as the calculations for a single GOE matrix \
(approximately 1800 seconds on a PowerMac G4 733 MHz).  As with the GOE \
matrix above, watch out for eigenvalues with absolute value greater than ",
  Cell[BoxData[
      \(TraditionalForm\`\@\(2  N\)\)]],
  ".  Also, note that when the two unfolded sequences are mixed together the \
mean spacing of the resulting sequence will be 0.5 rather than 1, so the \
spacing must be rescaled to have mean spacing 1."
}], "Text"],

Cell[BoxData[
    \(<< Statistics`ContinuousDistributions`\)], "Input"],

Cell[BoxData[
    \(<< Graphics`\)], "Input"],

Cell[BoxData[{
    \(\(n = 3000;\)\), "\n", 
    \(M1 = 
      Table[Which[i \[Equal] j, Random[NormalDistribution[0, 1]], i < j, 
          Random[NormalDistribution[0, 1/Sqrt[2]]], i > j, 0], {i, 1, n}, {j, 
          1, n}]; \), "\n", 
    \(M1Full = 
      Table[Which[i \[GreaterEqual] j, M1[\([\)\(j, i\)\(]\)], i < j, 
          M1[\([\)\(i, j\)\(]\)]], {i, 1, n}, {j, 1, n}]; \), "\n", 
    \(M2 = 
      Table[Which[i \[Equal] j, Random[NormalDistribution[0, 1]], i < j, 
          Random[NormalDistribution[0, 1/Sqrt[2]]], i > j, 0], {i, 1, n}, {j, 
          1, n}]; \), "\n", 
    \(M2Full = 
      Table[Which[i \[GreaterEqual] j, M2[\([\)\(j, i\)\(]\)], i < j, 
          M2[\([\)\(i, j\)\(]\)]], {i, 1, n}, {j, 1, n}]; \), "\n", 
    \(\(EV1 = Eigenvalues[M1Full];\)\), "\n", 
    \(\(UEV1 = 
        Table[\((EV1[\([\)\(i\)\(]\)]*Sqrt[2*n - EV1[\([\)\(i\)\(]\)]^2] + 
                2*n*ArcSin[EV1[\([\)\(i\)\(]\)]/Sqrt[2*n]] + n*Pi)\)/\((2*
                Pi)\), {i, 1, n}];\)\), "\n", 
    \(EV2 = Eigenvalues[M2Full]; \), "\n", 
    \(\(UEV2 = 
        Table[\((EV2[\([\)\(i\)\(]\)]*Sqrt[2*n - EV2[\([\)\(i\)\(]\)]^2] + 
                2*n*ArcSin[EV2[\([\)\(i\)\(]\)]/Sqrt[2*n]] + n*Pi)\)/\((2*
                Pi)\), {i, 1, n}];\)\), "\[IndentingNewLine]", 
    \(\(UEV = Join[UEV1, UEV2];\)\), "\n", 
    \(\(SUev = Sort[UEV];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(SpcUev = 
        Table[SUev[\([i + 1]\)] - SUev[\([i]\)], {i, 1, 
            2*n - 1}];\)\), "\n", 
    \(\(SpcUevNorm = SpcUev/Mean[SpcUev];\)\), "\n", 
    \(\(int\  = \ Table[0 + i/8, {i, 0, 40}];\)\), "\n", 
    \(GOE2Hist = 
      Histogram[SpcUevNorm, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] False]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Below we compare the histogram to the theoretical distribution for \
a combination of two sets of data that have GOE spacings.  The fit is very \
good.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[GOE2Hist, GOE2, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Random Matrix - GUE", "Section"],

Cell["\<\
In this section we will generate a Gaussian-random complex \
Hermitian matrix, compute its eigenvalues, calculate the level spacings, and \
generate a histogram of these level spacings.  This histogram closely matches \
the GUE distribution.  Be aware that these calculations take some time \
(roughly 900 seconds on a PowerMac G4 733 MHz).\
\>", "Text"],

Cell[TextData[{
  "First we must construct the matrix.  To do this we need to load the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " package entitled \"Continuous Distributions\" that is contained within \
the Statistics package."
}], "Text"],

Cell[BoxData[
    \(<< Statistics`ContinuousDistributions`\)], "Input"],

Cell["\<\
Now we construct and n by n random complex Hermitian matrix.  Each \
matrix element is a complex number with random real and imaginary parts that \
are Gaussian distributed with a mean of zero and a standard deviation of one \
(except the diagonal elements which are real and have standard deviation of \
square root of 2).  Here we generate a 3000 by 3000 matrix.  Once the matrix \
is generated we can find its eigenvalues and sort them.\
\>", "Text"],

Cell[BoxData[{
    \(\(n = 3000;\)\), "\n", 
    \(\(MGUE = 
        Table[Which[i \[Equal] j, Random[NormalDistribution[0, 1]], i < j, 
            Random[NormalDistribution[0, 1/2]] + 
              I*Random[NormalDistribution[0, 1/2]], i > j, 0], {i, 1, n}, {j, 
            1, n}];\)\), "\n", 
    \(\(MGUEFull = 
        Table[Which[i \[GreaterEqual] j, MGUE[\([j, i]\)], i < j, 
            Conjugate[MGUE[\([i, j]\)]]], {i, 1, n}, {j, 1, 
            n}];\)\), "\[IndentingNewLine]", 
    \(\(GUEev = Sort[Eigenvalues[MGUEFull]];\)\)}], "Input"],

Cell["\<\
For the GOE matrix above we found that the density of eigenvalues \
is not uniform, but thins out toward the edges.  The plot below shows the \
density of eigenvalues of our GUE matrix.  We see the same thinning of the \
eigenvalues toward the edges that we saw for the GOE matrix.  Indeed, the \
eigenvalues of the GUE matrix follow the same Wigner semicircle law as did \
those of the GOE matrix.  Note that we need to load the Graphics package if \
it has not already been loaded.\
\>", "Text"],

Cell[BoxData[
    \(<< Graphics`\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(int = Table[\(-25\) + 2*i, {i, 0, 25}];\)\), "\[IndentingNewLine]", 
    \(GUEHist = 
      Histogram[GUEev, HistogramCategories \[Rule] 25, 
        HistogramScale \[Rule] n, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<E\>", "\<\[Rho](E)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Below we plot the theoretical density of eigenvalues known as Wigner's \
semicircle law (because the curve takes the shape of a semicircle centered at \
zero with radius ",
  Cell[BoxData[
      \(TraditionalForm\`\(\(\@\(2  N\)\)\(,\)\)\)]],
  "where N is the dimension of the random matrix (and hence the number of \
eigenvalues)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(WSC = 
      Plot[Sqrt[2*n - x^2]/\((Pi)\), {x, \(-Sqrt[2*n]\), Sqrt[2*n]}, 
        PlotStyle \[Rule] {Thickness[0.02]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below comapres the computed eigenvalue density to the \
Wigner semicircle law.  The agreement is excellent.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[GUEHist, WSC, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  " The code below calculates the unfolded sequence of eigenvalues (using the \
same unfolding procedure as for the GOE matrix above) and then determines the \
spacings for these eigenvalues and generates a hisogram of the spacings.  ",
  "As with the GOE matrix above, watch out for eigenvalues with absolute \
value greater than ",
  Cell[BoxData[
      \(TraditionalForm\`\@\(2  N\)\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\[IndentingNewLine]\)\(UGUEev = 
      Table[\((GUEev[\([i]\)]*Sqrt[2*n - GUEev[\([i]\)]^2] + 
              2*n*ArcSin[GUEev[\([i]\)]/Sqrt[2*n]] + n*Pi)\)/\((2*Pi)\), {i, 
          1, n}]; SpcGUEev = 
      Table[UGUEev[\([i + 1]\)] - UGUEev[\([i]\)], {i, 1, n - 1}];\n
    \(int\  = \ Table[0 + i/10, {i, 0, 50}];\)\n
    GUEHist = 
      Histogram[SpcGUEev, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)\)\)], "Input"],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(UGUEev\\)\\\" is similar to existing symbol \
\\\"\\!\\(GUEev\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the level spacing hisogram of our random \
complex Hermitian matrix to the GUE distribution.  We see that that agreement \
is very good.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[GUEHist, GUE, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Classical Standard Map", "Section"],

Cell[TextData[{
  "We begin with the code for plotting orbits of the standard map.  This \
gives us an overal picture of the classical dynamics of this map.  See \"A \
computational approach to teaching conservative chaos\" by T. Timberlake (Am. \
J. Phys. ",
  StyleBox["72",
    FontWeight->"Bold"],
  ", 1002-1007, August 2004) for more details.  Note that the names of the \
variables change from (\[Theta],r) in the aforementioned paper to (q,p) \
here."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(K = 7; n = 400; q1 = 0; q2 = 0.5; np = 20;\), "\n", 
    \(\(f[{q_, p_}] := 
        N[{Mod[q + p - \((K/\((2*Pi)\))\)*Sin[2*Pi*q], 1], 
            Mod[p - \((K/\((2*Pi)\))\)*Sin[2*Pi*q], 1]}];\)\), "\n", 
    \(\(MapData\  = \ 
        Flatten[Table[
            Join[NestList[f, {q1, i/np}, n], NestList[f, {q2, i/np}, n]], {i, 
              0, np}], 1];\)\), "\n", 
    \(LP1 = 
      ListPlot[MapData, PlotStyle \[Rule] PointSize[0.005], 
        PlotRange \[Rule] {{0, 1}, {0, 1}}, Frame \[Rule] True, 
        RotateLabel \[Rule] 
          False, \[IndentingNewLine]TextStyle \[Rule] {"\<Times\>", 
            FontSize \[Rule] 16}, 
        FrameLabel \[Rule] {"\<q\>", "\<p\>", "\<\>", "\<\>"}, 
        Axes \[Rule] False, AspectRatio \[Rule] 1]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Quantum Standard Map", "Section"],

Cell["\<\
In this section we calculate the quasienergy eigenvalues for the \
quantum standard map.  The code below generates the Floquet matrix (or \
quantum map operator) and then determines the eigenvalues and eigenvectors.  \
We will need the eigenvectors later in order to separate the quasienergies \
for even and odd parity eigenstates.  Note: this calculation takes a long \
time (roughly 1 hour on a PowerMac G4 733 MHz).  You can shorten this time by \
reducing nq (the number of basis states / position grid pooints), but then \
the eigenvalues statistics will not be as good.\
\>", "Text"],

Cell[BoxData[{
    \(nq = 2000; k = 7;\), "\n", 
    \(\(U = 
        Table[N[Exp[I*Pi*\((i - j)\)^2/nq + I*k*nq*Cos[2*Pi*j/nq]/\((2*Pi)\)]/
              Sqrt[nq]], {i, 0, nq - 1}, {j, 0, nq - 1}];\)\), "\n", 
    \(\(Eval = Eigenvalues[U];\)\), "\n", 
    \(\(Evec = Eigenvectors[U];\)\)}], "Input"],

Cell["\<\
To verify that all of the eigenvalues have unit modulus (which they \
should, since the Floquet matrix is unitary) we can plot the eigenvalues in \
the complex plane as shown below.  It is clear that all points lie on the \
unit circle in the complex plane.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListPlot[Table[{Re[Eval[\([i]\)]], Im[Eval[\([i]\)]]}, {i, 1, nq}], 
      AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The code below calculates the quasienergies (from the eigenvalues \
of the Floquet matrix), sorts these quasienergies, computes the spacings \
between consecutive quasienergies, normalizes the spacings so that the mean \
spacing is 1, and then plots a hisogram of the normalized spacings.  Since we \
are using all of the eigenvalues, what we expect to see is a mixture of 2 \
independent data sets (one for even parity states and one for odd parity \
states).  If each data set follows Poisson statistics then the mixture will \
also be Poisson, but if each data set follows GOE statistics then the mixture \
will follow statistics for 2 sets of GOE data (see previous section).\
\>", \
"Text"],

Cell[BoxData[
    \(<< Graphics`\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Qnrg = Mod[Im[Log[Eval]], 2*Pi];\)\), "\[IndentingNewLine]", 
    \(\(SQnrg = Sort[Qnrg];\)\), "\[IndentingNewLine]", 
    \(\(int = Table[N[i*2*Pi/25], {i, 0, 25}];\)\), "\[IndentingNewLine]", 
    \(QHist = 
      Histogram[SQnrg, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] nq, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Qnrg = Mod[\(-Im[Log[Eval]]\), 2*Pi];\)\), "\[IndentingNewLine]", 
    \(\(SQnrg = Sort[Qnrg];\)\), "\[IndentingNewLine]", 
    \(\(QSpc = 
        Join[Table[
            SQnrg[\([i + 1]\)] - SQnrg[\([i]\)], {i, 1, 
              nq - 1}], {SQnrg[\([1]\)] + 2*Pi - 
              SQnrg[\([nq]\)]}];\)\), "\[IndentingNewLine]", 
    \(\(QSpcNorm = QSpc/Mean[QSpc];\)\), "\[IndentingNewLine]", 
    \(\(int\  = \ Table[0 + i/8, {i, 0, 40}];\)\), "\n", 
    \(QHist2 = 
      Histogram[QSpcNorm, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(SQnrg\\)\\\" is similar to existing symbol \
\\\"\\!\\(Qnrg\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(QHist\\)\\\" is similar to existing symbol \
\\\"\\!\\(MHist\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the mixed level spacing histogram to the \
theoretical distributions for Poisson statistics and for 2 sets of GOE data.  \
At high values of kick strength (large k) the histogram should match the 2 \
GOE curve.  At low kick strengths there are degeneracies that lead to \
deviations from Poisson statistics.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[QHist2, Curves2, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "The code below tests the parity of each of the eigenstates of the Floquet \
matrix, separates the eigenvalues of the even and odd states, computes the \
quasienergies for even and odd states, sorts each set of quasienergies, \
determines the spacings between consecutive quasienergies in each set, \
combines the spacing data from the two sets, normalizes the spacings so that \
the mean spacing is 1, and then generates a histogram of the level spacings.  \
By calculating level spacings only between members of the same parity class \
we avoid the problem of mixing two independent data sets that we encountered \
above.  Note that ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " labels the basis vectors from 1 to N instead of from 0 to N-1, as is done \
in the article.  Also, the periodicity of the wavefunction is used in \
constructing the ParityTest function.  Because of these two issues the sum in \
the ParityTest function looks a bit different from the sum for testing parity \
mentioned in the article, but they are equivalent."
}], "Text"],

Cell[BoxData[{
    \(\(ParityTest[
          i_] := \((Sum[
                Abs[Evec[\([i, j]\)] + Evec[\([i, nq - j + 2]\)]]^2, {j, 2, 
                  nq/2}] + Abs[2*Evec[\([i, 1]\)]]^2 + 
              Abs[2*Evec[\([i, nq/2 + 1]\)]]^2 > 1)\);\)\), "\n", 
    \(EvalEven = Eval[\([Select[Range[1, nq], ParityTest[#] &]]\)]; 
    EvalOdd = 
      Eval[\([Select[Range[1, nq], Not[ParityTest[#]] &]]\)];\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(OQnrg = Mod[Im[Log[EvalOdd]], 2*Pi];\)\), "\[IndentingNewLine]", 
    \(\(SOQnrg = Sort[OQnrg];\)\), "\[IndentingNewLine]", 
    \(\(OQSpc = 
        Join[Table[
            SOQnrg[\([i + 1]\)] - SOQnrg[\([i]\)], {i, 1, 
              Length[SOQnrg] - 1}], {SOQnrg[\([1]\)] + 2*Pi - 
              SOQnrg[\([Length[SOQnrg]]\)]}];\)\), "\[IndentingNewLine]", 
    \(\(EQnrg = Mod[Im[Log[EvalEven]], 2*Pi];\)\), "\[IndentingNewLine]", 
    \(\(SEQnrg = Sort[EQnrg];\)\), "\[IndentingNewLine]", 
    \(\(EQSpc = 
        Join[Table[
            SEQnrg[\([i + 1]\)] - SEQnrg[\([i]\)], {i, 1, 
              Length[SEQnrg] - 1}], {SEQnrg[\([1]\)] + 2*Pi - 
              SEQnrg[\([Length[SEQnrg]]\)]}];\)\), "\[IndentingNewLine]", 
    \(\(AllQSpc = Join[EQSpc, OQSpc];\)\), "\[IndentingNewLine]", 
    \(\(AllQSpcNorm = AllQSpc/Mean[AllQSpc];\)\), "\[IndentingNewLine]", 
    \(\(int\  = \ Table[0 + i/8, {i, 0, 40}];\)\), "\n", 
    \(QHist1 = 
      Histogram[AllQSpcNorm, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the separated level spacing histogram to \
the theoretical distributions for Poisson statistics and GOE statistics.  For \
weak kicks (k \[TildeTilde] 0) there are degeneracies that cause deviations \
from Poisson statistics, but the deviations are not as bad as for the mixed \
data and they mostly disappear as the kick strength is increased above 0 \
(while still remaining small).  For large k (when the classical system is \
fully chaotic) the data match the GOE distribution.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[QHist1, Curves1, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Prime Numbers", "Section"],

Cell["\<\
The code below generates a list of the first 10,000 prime numbers \
and creates a histogram to show the density of the primes as a function of \
the size of the primes.\
\>", "Text"],

Cell[BoxData[
    \(<< Graphics`\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(n = 10000;\)\), "\n", 
    \(\(P = Table[Prime[i], {i, 1, n}];\)\), "\n", 
    \(\(int = 
        Table[P[\([1]\)] + i*\((P[\([n]\)] - P[\([1]\)])\)/25, {i, 0, 
            25}];\)\), "\n", 
    \(PDensity = 
      Histogram[P, HistogramScale \[Rule] n, HistogramCategories \[Rule] int, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<p\>", "\<\[Rho](p)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \(Histogram::"rtail1" \(\(:\)\(\ \)\) 
      "Warning: One point from the right tail of the data, greater than or \
equal to \!\(104729\), is not included in histogram."\)], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
Number theory tells us that the density of primes near the prime p \
should be 1/ln(p).  Below we plot this reciprocal logarithm function.\
\>", \
"Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(PD = 
      Plot[1/\((Log[x])\), {x, 2, 1.25*10^5}, 
        PlotStyle \[Rule] {Thickness[0.015]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the computed density of primes with the \
theoretical (1/ln(p)) prediction.  The agreement is very good.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[PDensity, PD, AspectRatio \[Rule] 1, 
      PlotRange \[Rule] {{0, 10^5}, {0, 0.15}}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
To analyze the spacings between primes we must first account for \
their non-uniform density.  To do this we must \"unfold\" the sequence of \
primes.  For the primes, this means rescaling each prime p to e=Li(p), where \
Li(x) is the Log Integral function.  The code below carries out this \
unfolding and then computes a histogram displaying the density of the \
unfolded primes.  Note that the density is essentially uniform \
throughout.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(n = 10000;\)\), "\n", 
    \(\(UP = Table[N[LogIntegral[Prime[i]]], {i, 1, n + 1}];\)\), "\n", 
    \(\(int = 
        Table[UP[\([1]\)] + i*\((UP[\([n]\)] - UP[\([1]\)])\)/25, {i, 0, 
            25}];\)\), "\n", 
    \(UPHist = 
      Histogram[UP, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] n, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<e\>", "\<\[Rho](e)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(UPHist\\)\\\" is similar to existing symbol \
\\\"\\!\\(PHist\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"],

Cell[BoxData[
    \(Histogram::"rtail" \(\(:\)\(\ \)\) 
      "Warning: \!\(2\) points from the right tail of the data, greater than \
or equal to \!\(10039.736337105796`\), are not included in histogram."\)], \
"Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The code in this section computes the spacings between the first \
10,000 primes (unfolded so that the spacings are roughly uniform), rescales \
the spacings so that the mean is 1, and creates a histogram of the level \
spacings.  Again, we need the Graphics package to create the histogram.\
\>", \
"Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(PSpacing = 
        Table[UP[\([i + 1]\)] - UP[\([i]\)], {i, 1, n}];\)\), "\n", 
    \(\(PSpacingNorm = PSpacing/Mean[PSpacing];\)\), "\n", 
    \(\(int\  = \ Table[0 + i/5, {i, 0, 25}];\)\), "\n", 
    \(PHist = 
      Histogram[PSpacingNorm, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \(Histogram::"rtail" \(\(:\)\(\ \)\) 
      "Warning: \!\(14\) points from the right tail of the data, greater than \
or equal to \!\(5\), are not included in histogram."\)], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the spacing distribution for the first \
10,000 unfolded primes to the Poisson distribution.  While the prime spacings \
do seem to exhibit an exponential decay, there is a noticeable shortage of \
small spacings that leads to a discrepancy between the primes spacings and \
the Poisson distribution.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[PHist, Poisson, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "The plot below shows the density of the primes between the ",
  Cell[BoxData[
      \(TraditionalForm\`10\^12 + 
        1  st\ and\ the\ 10\^12 + \(10\^4\) th\ \(\(primes\)\(.\)\)\)]],
  " It is clear that the density of primes is fairly uniform over this range \
(which is consistent with the fact that the function 1/ln(x) does not change \
much over this range).  Note that the drop-off in the last bar of the \
histogram occurs because of the way the intervals are defined (i.e. the last \
interval extends well beyond the last prime number in the list)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(n = 10000;\)\), "\n", 
    \(\(P2 = Table[Prime[10^12 + i] - Prime[10^12], {i, 1, n}];\)\), "\n", 
    \(\(int = 
        Table[P2[\([1]\)] + i*\((P2[\([n]\)] - P2[\([1]\)])\)/25, {i, 0, 
            25}];\)\), "\[IndentingNewLine]", 
    \(P2DHist = 
      Histogram[P2, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] n, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, 
        FrameLabel \[Rule] {\*"\"\<p-\!\(p\_\(\_\(10\^12\)\)\)\>\"", \
"\<\[Rho](p)\>"}, RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \(Histogram::"rtail1" \(\(:\)\(\ \)\) 
      "Warning: One point from the right tail of the data, greater than or \
equal to \!\(314316\), is not included in histogram."\)], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Since the density of primes between the ",
  Cell[BoxData[
      \(TraditionalForm\`10\^12 + 
        1  st\ and\ the\ 10\^12 + \(10\^4\) th\ primes\)]],
  "is roughly uniform, we do not need to unfold this sequence of primes in \
order to calculate the spacing statistics.  The code below generates a \
histogram of the spacings between consecutive primes in this range, without \
unfolding (but still scaled so that the mean spacing is 1)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(n = 10000;\)\), "\n", 
    \(\(P3 = Table[Prime[10^12 + i], {i, 1, n + 1}];\)\), "\n", 
    \(\(P3Spacing = 
        Table[P3[\([i + 1]\)] - P3[\([i]\)], {i, 1, n}];\)\), "\n", 
    \(\(P3SpacingNorm = P3Spacing/Mean[P3Spacing];\)\), "\n", 
    \(\(int\  = \ Table[0 + i/5, {i, 0, 25}];\)\), "\n", 
    \(P3Hist = 
      Histogram[P3SpacingNorm, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(P3Hist\\)\\\" is similar to existing symbol \
\\\"\\!\\(PHist\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"],

Cell[BoxData[
    \(Histogram::"rtail" \(\(:\)\(\ \)\) 
      "Warning: \!\(39\) points from the right tail of the data, greater than \
or equal to \!\(5\), are not included in histogram."\)], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Finally we show a comparison of the Poisson distribution to the histogram \
of prime spacings near the ",
  Cell[BoxData[
      \(TraditionalForm\`\(10\^12\) th\ \(\(prime\)\(.\)\)\)]],
  " We see that the agreement is very good in this case (although there is \
still a small shortage of small spacings)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[P3Hist, Poisson, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Zeros of Riemann Zeta Function", "Section"],

Cell[TextData[{
  "In this section we will compute the level spacing distrubution for the \
imaginary parts of the nontrivial zeros of the Riemann zeta function (which I \
will refer to as \"zeta zeros\" from here on).  Values of the zeta zeros have \
been computed by Andrew Odlyzko and generously made available on his website \
(http://www.dtc.umn.edu/~odlyzko/zeta_tables/).  To use this data, go to \
Odlyzko's website and download the text files containing the zeta zeros.  \
Name the files according to the names given on the website (zeros1, zeros3, \
etc.).  You will need to cut out the explanations of the data given at the \
beginning of each file, so that what remains is just a list of numbers that \
can be read into ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  ".  Put the files into a convenient directory (such as the directory where \
this notebook is located) and then set the current directory to that \
directory using a command such as the one shown below (which will obviously \
need to be modified)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(SetDirectory["\</Users/timbertk/Documents/Research/RandomMatrix/\>"]\)],\
 "Input"],

Cell[BoxData[
    \("/Users/timbertk/Documents/Research/RandomMatrix"\)], "Output"]
}, Open  ]],

Cell["\<\
We'll need to load the Graphics package if that has not already \
been done.\
\>", "Text"],

Cell[BoxData[
    \(<< Graphics`\)], "Input"],

Cell["\<\
The zeta zeros are not uniformly distributed, on average. The code \
below creates a histogram of the density of the first 100,000 zeta \
zeros.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ZetaZero1 = ReadList["\<zeros1\>", Real];\)\), "\n", 
    \(\(L1 = Length[ZetaZero1];\)\), "\[IndentingNewLine]", 
    \(\(int = 
        Table[ZetaZero1[\([1]\)] + 
            i*\((ZetaZero1[\([L1]\)] - ZetaZero1[\([1]\)])\)/25, {i, 0, 
            25}];\)\), "\[IndentingNewLine]", 
    \(ZHist1 = 
      Histogram[ZetaZero1, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] L1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, 
        FrameLabel \[Rule] {"\<\[Gamma]\>", "\<\[Rho](\[Gamma])\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \(Histogram::"rtail1" \(\(:\)\(\ \)\) 
      "Warning: One point from the right tail of the data, greater than or \
equal to \!\(74920.827498994`\), is not included in histogram."\)], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Number theory tells us that if ",
  Cell[BoxData[
      \(TraditionalForm\`\[Gamma]\_n\)]],
  " is the nth zeta zero, then the average density of zeta zeros near ",
  Cell[BoxData[
      \(TraditionalForm\`\[Gamma]\_n\)]],
  " is ln(",
  Cell[BoxData[
      \(TraditionalForm\`\[Gamma]\_n\)]],
  "/(2\[Pi]))/(2\[Pi]).  Below is a plot of the function ln(x/(2\[Pi]))/(2\
\[Pi])."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ZD = 
      Plot[Log[x/\((2*Pi)\)]/\((2*Pi)\), {x, 7, 80000}, 
        PlotStyle \[Rule] {Thickness[0.015]}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the computed density of the zeta zeros to \
the theoretical prediction.  The agreement is nearly perfect.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[ZHist1, ZD, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The unfolded zeta zeros are given by \
\>", "Text"],

Cell[BoxData[
    \(e = \[Gamma]\ \((ln \((\[Gamma]/\((2  \[Pi]\ )\))\) - 
              1)\)/\(\((2  \[Pi])\)\(.\)\)\)], "DisplayFormula"],

Cell["\<\
The code below creates a histogram showing the density of the \
unfolded zeta zeros.  We see that the density is uniform.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ZNorm = 
        Table[ZetaZero1[\([i]\)]*\((Log[ZetaZero1[\([i]\)]/\((2*Pi)\)] - 
                  1)\)/\((2*Pi)\), {i, 2, 
            100000}];\)\), "\[IndentingNewLine]", 
    \(\(LN = Length[ZNorm];\)\), "\[IndentingNewLine]", 
    \(\(int = 
        Table[ZNorm[\([1]\)] + 
            i*\((ZNorm[\([LN]\)] - ZNorm[\([1]\)])\)/25, {i, 0, 
            25}];\)\), "\n", 
    \(ZHist1 = 
      Histogram[ZNorm, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] L1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<e\>", "\<\[Rho](e)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \(Histogram::"rtail1" \(\(:\)\(\ \)\) 
      "Warning: One point from the right tail of the data, greater than or \
equal to \!\(99998.53008849114`\), is not included in histogram."\)], \
"Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The code below creates the level spacing histogram for the first \
100,000 unfolded zeta zeros.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ZSpacing1 = 
        Table[ZNorm[\([i + 1]\)] - ZNorm[\([i]\)], {i, 1, 
            L1 - 2}];\)\), "\n", 
    \(\(int\  = \ Table[0 + i/8, {i, 0, 40}];\)\), "\n", 
    \(ZHist1 = 
      Histogram[ZSpacing1, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the level spacing hisotgram for the first \
100,000 zeta zeros to the theoretical GUE distribution.  The fit is not \
perfect, but it is good, but not perfect.  In particular, there seems to be \
an excess of spacings near the peak of the distribution.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[ZHist1, GUE, AspectRatio \[Rule] 1, 
      PlotRange \[Rule] {{0, 3.5}, {0, 1.1}}]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "Odlyzko's website also provides tables of zeta zeros that are far up the \
critical line.  For example, the data file titled \"zeros5\" contains the ",
  Cell[BoxData[
      \(TraditionalForm\`zeta\ zeros\ 10\^22\)]],
  "+1 to ",
  Cell[BoxData[
      \(TraditionalForm\`10\^22\)]],
  "+",
  Cell[BoxData[
      \(TraditionalForm\`10\^4\)]],
  ".  Because these numbers are so large the density of zeta zeros in this \
range is approximately uniform and we could avoid the unfolding altogether \
and simply rescale the average spacing to 1.  The code below generates a \
histogram showing the density of the zeta zeros in this range.  It is clear \
that the density is roughly uniform for this range of values.  Note that the \
numbers listed in Odlyzko's table (file \"zeros5\" on his website) are \
actually the values of the zeta zeros minus ",
  "1370919909931995300000."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ZetaZero5 = ReadList["\<zeros5\>", Real];\)\), "\n", 
    \(\(L5 = Length[ZetaZero5];\)\), "\[IndentingNewLine]", 
    \(\(int = 
        Table[ZetaZero5[\([1]\)] + 
            i*\((ZetaZero5[\([L5]\)] - ZetaZero5[\([1]\)])\)/25, {i, 0, 
            25}];\)\), "\[IndentingNewLine]", 
    \(ZHist1 = 
      Histogram[ZetaZero5, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] L5, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, 
        FrameLabel \[Rule] {"\<\[Gamma]-1370919909931995300000\>", "\<\[Rho](\
\[Gamma])\>"}, RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \(Histogram::"rtail1" \(\(:\)\(\ \)\) 
      "Warning: One point from the right tail of the data, greater than or \
equal to \!\(9568.33538975`\), is not included in histogram."\)], "Message"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell[TextData[{
  "The code below generates the level spacing histogram for the zeta zeros",
  Cell[BoxData[
      \(TraditionalForm\`\(\(\ \)\(10\^22\)\)\)]],
  "+1 to ",
  Cell[BoxData[
      \(TraditionalForm\`10\^22\)]],
  "+",
  Cell[BoxData[
      \(TraditionalForm\`10\^4\)]],
  ".  There is no need to unfold this sequence since the zeta zeros are \
uniformly distributed in this range (see previous plot).  All that is needed \
is to rescale the spacings so that the mean spacing is 1."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ZSpacing5 = 
        Table[ZetaZero5[\([i + 1]\)] - ZetaZero5[\([i]\)], {i, 1, 
            L5 - 1}];\)\), "\n", 
    \(\(ZNorm5 = ZSpacing5/Mean[ZSpacing5];\)\), "\[IndentingNewLine]", 
    \(\(int\  = \ Table[0 + i/8, {i, 0, 40}];\)\), "\n", 
    \(ZHist5 = 
      Histogram[ZNorm5, HistogramCategories \[Rule] int, 
        HistogramScale \[Rule] 1, 
        TextStyle \[Rule] {"\<Times\>", FontSize \[Rule] 16}, 
        Frame \[Rule] True, FrameLabel \[Rule] {"\<s\>", "\<P(s)\>"}, 
        RotateLabel \[Rule] False]\)}], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]],

Cell["\<\
The plot below compares the level spacing histogram for these zeta \
zeros that are high up the critical line to the theoretical GUE distribution. \
 The fit is quite good, indicating that the spacings between the zeta zeros \
more closely follow GUE statistics as we go farther up the critical line.  \
This implies that the limiting distribution (i.e. the distribution for the \
entire infinite set) for the spacings between zeta zeros is the GUE \
distribution.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Show[ZHist5, GUE, AspectRatio \[Rule] 1]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[SkeletonIndicator]  Graphics  \[SkeletonIndicator]\),
      False,
      Editable->False]], "Output"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
},
FrontEndVersion->"5.1 for Macintosh",
ScreenRectangle->{{0, 1280}, {0, 998}},
WindowSize->{588, 689},
WindowMargins->{{194, Automatic}, {Automatic, 74}},
PrintingCopies->1,
PrintingPageRange->{1, Automatic}
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{

Cell[CellGroupData[{
Cell[1776, 53, 52, 0, 136, "Title"],
Cell[1831, 55, 59, 0, 52, "Subtitle"],

Cell[CellGroupData[{
Cell[1915, 59, 31, 0, 69, "Section"],
Cell[1949, 61, 1097, 21, 180, "Text"]
}, Open  ]],

Cell[CellGroupData[{
Cell[3083, 87, 57, 0, 69, "Section"],
Cell[3143, 89, 372, 6, 78, "Text"],
Cell[3518, 97, 58, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[3601, 101, 125, 3, 43, "Input"],
Cell[3729, 106, 130, 3, 27, "Output"]
}, Open  ]],
Cell[3874, 112, 364, 8, 64, "Text"],

Cell[CellGroupData[{
Cell[4263, 124, 154, 3, 43, "Input"],
Cell[4420, 129, 130, 3, 27, "Output"]
}, Open  ]],
Cell[4565, 135, 165, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[4755, 143, 134, 3, 43, "Input"],
Cell[4892, 148, 130, 3, 27, "Output"]
}, Open  ]],
Cell[5037, 154, 89, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[5151, 161, 193, 4, 75, "Input"],
Cell[5347, 167, 130, 3, 27, "Output"]
}, Open  ]],
Cell[5492, 173, 238, 5, 62, "Text"],

Cell[CellGroupData[{
Cell[5755, 182, 208, 4, 75, "Input"],
Cell[5966, 188, 130, 3, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[6133, 196, 279, 6, 123, "Input"],
Cell[6415, 204, 130, 3, 27, "Output"]
}, Open  ]],
Cell[6560, 210, 174, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[6759, 218, 140, 3, 43, "Input"],
Cell[6902, 223, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[7081, 232, 33, 0, 69, "Section"],
Cell[7117, 234, 539, 10, 96, "Text"],
Cell[7659, 246, 45, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[7729, 251, 600, 11, 155, "Input"],
Cell[8332, 264, 203, 3, 49, "Message"],
Cell[8538, 269, 130, 3, 27, "Output"]
}, Open  ]],
Cell[8683, 275, 208, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[8916, 283, 76, 1, 27, "Input"],
Cell[8995, 286, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[9174, 295, 38, 0, 69, "Section"],
Cell[9215, 297, 361, 6, 78, "Text"],
Cell[9579, 305, 255, 6, 48, "Text"],
Cell[9837, 313, 71, 1, 27, "Input"],
Cell[9911, 316, 424, 7, 94, "Text"],
Cell[10338, 325, 478, 10, 123, "Input"],
Cell[10819, 337, 475, 8, 94, "Text"],
Cell[11297, 347, 45, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[11367, 352, 311, 6, 75, "Input"],
Cell[11681, 360, 130, 3, 27, "Output"]
}, Open  ]],
Cell[11826, 366, 364, 8, 64, "Text"],

Cell[CellGroupData[{
Cell[12215, 378, 154, 3, 43, "Input"],
Cell[12372, 383, 130, 3, 27, "Output"]
}, Open  ]],
Cell[12517, 389, 151, 3, 46, "Text"],

Cell[CellGroupData[{
Cell[12693, 396, 77, 1, 27, "Input"],
Cell[12773, 399, 130, 3, 27, "Output"]
}, Open  ]],
Cell[12918, 405, 413, 7, 78, "Text"],
Cell[13334, 414, 167, 3, 38, "DisplayFormula"],
Cell[13504, 419, 432, 9, 80, "Text"],

Cell[CellGroupData[{
Cell[13961, 432, 480, 9, 155, "Input"],
Cell[14444, 443, 130, 3, 27, "Output"]
}, Open  ]],
Cell[14589, 449, 138, 3, 46, "Text"],

Cell[CellGroupData[{
Cell[14752, 456, 481, 10, 107, "Input"],
Cell[15236, 468, 130, 3, 27, "Output"]
}, Open  ]],
Cell[15381, 474, 194, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[15600, 482, 74, 1, 27, "Input"],
Cell[15677, 485, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[15856, 494, 41, 0, 69, "Section"],
Cell[15900, 496, 896, 14, 144, "Text"],
Cell[16799, 512, 71, 1, 27, "Input"],
Cell[16873, 515, 45, 1, 27, "Input"],
Cell[16921, 518, 1366, 27, 411, "Input"],

Cell[CellGroupData[{
Cell[18312, 549, 457, 10, 107, "Input"],
Cell[18772, 561, 130, 3, 27, "Output"]
}, Open  ]],
Cell[18917, 567, 175, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[19117, 575, 76, 1, 27, "Input"],
Cell[19196, 578, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[19375, 587, 38, 0, 69, "Section"],
Cell[19416, 589, 364, 6, 78, "Text"],
Cell[19783, 597, 255, 6, 48, "Text"],
Cell[20041, 605, 71, 1, 27, "Input"],
Cell[20115, 608, 463, 7, 94, "Text"],
Cell[20581, 617, 552, 11, 171, "Input"],
Cell[21136, 630, 507, 8, 94, "Text"],
Cell[21646, 640, 45, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[21716, 645, 387, 7, 91, "Input"],
Cell[22106, 654, 130, 3, 27, "Output"]
}, Open  ]],
Cell[22251, 660, 364, 8, 64, "Text"],

Cell[CellGroupData[{
Cell[22640, 672, 154, 3, 43, "Input"],
Cell[22797, 677, 130, 3, 27, "Output"]
}, Open  ]],
Cell[22942, 683, 140, 3, 46, "Text"],

Cell[CellGroupData[{
Cell[23107, 690, 74, 1, 27, "Input"],
Cell[23184, 693, 130, 3, 27, "Output"]
}, Open  ]],
Cell[23329, 699, 424, 9, 80, "Text"],

Cell[CellGroupData[{
Cell[23778, 712, 640, 12, 203, "Input"],
Cell[24421, 726, 359, 5, 35, "Message"],
Cell[24783, 733, 130, 3, 27, "Output"]
}, Open  ]],
Cell[24928, 739, 184, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[25137, 747, 74, 1, 27, "Input"],
Cell[25214, 750, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[25393, 759, 41, 0, 69, "Section"],
Cell[25437, 761, 471, 10, 80, "Text"],

Cell[CellGroupData[{
Cell[25933, 775, 792, 16, 235, "Input"],
Cell[26728, 793, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[26907, 802, 39, 0, 69, "Section"],
Cell[26949, 804, 600, 9, 110, "Text"],
Cell[27552, 815, 301, 6, 155, "Input"],
Cell[27856, 823, 281, 5, 62, "Text"],

Cell[CellGroupData[{
Cell[28162, 832, 130, 2, 43, "Input"],
Cell[28295, 836, 130, 3, 27, "Output"]
}, Open  ]],
Cell[28440, 842, 705, 11, 126, "Text"],
Cell[29148, 855, 45, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[29218, 860, 508, 9, 123, "Input"],
Cell[29729, 871, 130, 3, 27, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[29896, 879, 768, 15, 171, "Input"],
Cell[30667, 896, 357, 5, 35, "Message"],
Cell[31027, 903, 358, 5, 35, "Message"],
Cell[31388, 910, 130, 3, 27, "Output"]
}, Open  ]],
Cell[31533, 916, 355, 6, 78, "Text"],

Cell[CellGroupData[{
Cell[31913, 926, 77, 1, 27, "Input"],
Cell[31993, 929, 130, 3, 27, "Output"]
}, Open  ]],
Cell[32138, 935, 1083, 17, 176, "Text"],
Cell[33224, 954, 419, 8, 107, "Input"],

Cell[CellGroupData[{
Cell[33668, 966, 1245, 23, 315, "Input"],
Cell[34916, 991, 130, 3, 27, "Output"]
}, Open  ]],
Cell[35061, 997, 529, 8, 94, "Text"],

Cell[CellGroupData[{
Cell[35615, 1009, 77, 1, 27, "Input"],
Cell[35695, 1012, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[35874, 1021, 32, 0, 69, "Section"],
Cell[35909, 1023, 192, 4, 46, "Text"],
Cell[36104, 1029, 45, 1, 27, "Input"],

Cell[CellGroupData[{
Cell[36174, 1034, 498, 10, 123, "Input"],
Cell[36675, 1046, 202, 3, 49, "Message"],
Cell[36880, 1051, 130, 3, 27, "Output"]
}, Open  ]],
Cell[37025, 1057, 164, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[37214, 1065, 131, 3, 43, "Input"],
Cell[37348, 1070, 130, 3, 27, "Output"]
}, Open  ]],
Cell[37493, 1076, 152, 3, 46, "Text"],

Cell[CellGroupData[{
Cell[37670, 1083, 123, 2, 43, "Input"],
Cell[37796, 1087, 130, 3, 27, "Output"]
}, Open  ]],
Cell[37941, 1093, 465, 8, 94, "Text"],

Cell[CellGroupData[{
Cell[38431, 1105, 530, 11, 123, "Input"],
Cell[38964, 1118, 359, 5, 35, "Message"],
Cell[39326, 1125, 222, 4, 49, "Message"],
Cell[39551, 1131, 130, 3, 27, "Output"]
}, Open  ]],
Cell[39696, 1137, 317, 6, 62, "Text"],

Cell[CellGroupData[{
Cell[40038, 1147, 518, 10, 123, "Input"],
Cell[40559, 1159, 203, 3, 49, "Message"],
Cell[40765, 1164, 130, 3, 27, "Output"]
}, Open  ]],
Cell[40910, 1170, 348, 6, 78, "Text"],

Cell[CellGroupData[{
Cell[41283, 1180, 76, 1, 27, "Input"],
Cell[41362, 1183, 130, 3, 27, "Output"]
}, Open  ]],
Cell[41507, 1189, 591, 10, 94, "Text"],

Cell[CellGroupData[{
Cell[42123, 1203, 585, 12, 136, "Input"],
Cell[42711, 1217, 202, 3, 49, "Message"],
Cell[42916, 1222, 130, 3, 27, "Output"]
}, Open  ]],
Cell[43061, 1228, 473, 9, 78, "Text"],

Cell[CellGroupData[{
Cell[43559, 1241, 620, 12, 155, "Input"],
Cell[44182, 1255, 359, 5, 35, "Message"],
Cell[44544, 1262, 203, 3, 49, "Message"],
Cell[44750, 1267, 130, 3, 27, "Output"]
}, Open  ]],
Cell[44895, 1273, 337, 7, 62, "Text"],

Cell[CellGroupData[{
Cell[45257, 1284, 77, 1, 27, "Input"],
Cell[45337, 1287, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[45516, 1296, 49, 0, 69, "Section"],
Cell[45568, 1298, 1049, 17, 178, "Text"],

Cell[CellGroupData[{
Cell[46642, 1319, 103, 2, 43, "Input"],
Cell[46748, 1323, 83, 1, 27, "Output"]
}, Open  ]],
Cell[46846, 1327, 100, 3, 30, "Text"],
Cell[46949, 1332, 45, 1, 27, "Input"],
Cell[46997, 1335, 168, 4, 46, "Text"],

Cell[CellGroupData[{
Cell[47190, 1343, 632, 13, 155, "Input"],
Cell[47825, 1358, 212, 3, 49, "Message"],
Cell[48040, 1363, 130, 3, 27, "Output"]
}, Open  ]],
Cell[48185, 1369, 409, 12, 46, "Text"],

Cell[CellGroupData[{
Cell[48619, 1385, 141, 3, 43, "Input"],
Cell[48763, 1390, 130, 3, 27, "Output"]
}, Open  ]],
Cell[48908, 1396, 153, 3, 46, "Text"],

Cell[CellGroupData[{
Cell[49086, 1403, 72, 1, 27, "Input"],
Cell[49161, 1406, 130, 3, 27, "Output"]
}, Open  ]],
Cell[49306, 1412, 61, 2, 30, "Text"],
Cell[49370, 1416, 139, 2, 23, "DisplayFormula"],
Cell[49512, 1420, 145, 3, 46, "Text"],

Cell[CellGroupData[{
Cell[49682, 1427, 695, 15, 187, "Input"],
Cell[50380, 1444, 216, 4, 49, "Message"],
Cell[50599, 1450, 130, 3, 27, "Output"]
}, Open  ]],
Cell[50744, 1456, 119, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[50888, 1463, 481, 10, 107, "Input"],
Cell[51372, 1475, 130, 3, 27, "Output"]
}, Open  ]],
Cell[51517, 1481, 300, 5, 62, "Text"],

Cell[CellGroupData[{
Cell[51842, 1490, 120, 2, 43, "Input"],
Cell[51965, 1494, 130, 3, 27, "Output"]
}, Open  ]],
Cell[52110, 1500, 906, 19, 126, "Text"],

Cell[CellGroupData[{
Cell[53041, 1523, 648, 13, 171, "Input"],
Cell[53692, 1538, 210, 3, 49, "Message"],
Cell[53905, 1543, 130, 3, 27, "Output"]
}, Open  ]],
Cell[54050, 1549, 507, 13, 62, "Text"],

Cell[CellGroupData[{
Cell[54582, 1566, 559, 11, 139, "Input"],
Cell[55144, 1579, 130, 3, 27, "Output"]
}, Open  ]],
Cell[55289, 1585, 488, 8, 94, "Text"],

Cell[CellGroupData[{
Cell[55802, 1597, 73, 1, 27, "Input"],
Cell[55878, 1600, 130, 3, 27, "Output"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

